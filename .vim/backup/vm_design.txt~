                    +---------------------------+
                    |           CS 439          |
	 			    | PROJECT 3: VIRTUAL MEMORY	|
				    |	   DESIGN DOCUMENT	    |
		  			+---------------------------+


****EACH student submits a (unique) design document.****

---- Name ----

>> Fill your name, UT EID, CS login, email address, and unique number:

Name: Andy Tseng
EID: art2589
CS login: andytsen
Email: andydomokun@gmail.com    
Unique Number: 51075


Slip days used on this project: 2

---- GROUP ----

>> Fill the names, UT EIDs, CS logins, email addresses, and unique numbers
>> of your group members.  Also fill in each person's ranking on the 
>> partner evaluation scale, as determined by you.

Name1: Denny Stasaski
EID1: ds42833
CS login: ds42833
Email: denny.stasaski@utexas.edu
Unique Number: 51080
Ranking (scale below): Excellent

Name2: Khiem Tang
EID2: klt2399
CS login: kltang
Email: tang.khiem@yahoo.com
Unique Number: 51080
Ranking (scale below): Satfisfactory

Name3:
EID2:
CS login:
Email:
Unique Number:
Ranking (scale below):


---- PARTNER EVALUATION SCALE ----

>> Excellent: Consistently went above and beyond - tutored others, carried
>> more than his/her fair share of the load.

>> Very Good: Consistently did what he/she was supposed to do, very well
>> prepared and cooperative.

>> Satisfactory: Usually did what he/she was supposed to do, minimally
>> prepared and cooperative.

>> Marginal: Sometimes failed to show up and/or rarely prepared.

>> Deficient: Often failed to show up and/or rarely prepared.

>> Unsatisfactory: Consistently failed to show up and/or unprepared.

>> Superficial: Practically no participation.

>> No Show: No participation at all.


---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

========= frame.c ===========
struct frame {          /* Entry for the frame table */
    void *kpage;        /* physical memory address that frame holds */
    void *spte_ptr;     /* page that the frame points to */
    struct list_elem frame_elem;    /* list_elem for the frame table  */
    struct lock frame_lock;         /* lock for the frames */ 

};

struct list frame_table;        /* frame table that holds all frames  */

page.h
#define FILE_PAGE (1) /* Page type that denotes it is a file page */
#define SWAP_PAGE (2)   page type that denotes it is a swap page
#define STACK_PAGE (3)  page type that denotes that it is a zero/stack page

#define STACK_LIMIT (2000)      number of pages in 8MB

/* Supplemental Page Semaphore */ 
struct lock page_lock;          Used to synchronize the supplementary page table

/* Supplmental Page Struct */ 
struct spte {
    int type;                    /* page type */ 
    void* upage;                 /* upage that it represents */ 
    struct list_elem spte_elem;
    bool loaded;                 /* True if it is in the FT */
    bool write;                  True if the page is writable false otherwise   
}; 

struct list spt /* every thread has a spt that holds extra info for the pages */


---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

Each frame holds a kpage that is useable to find the frame within the frame
table. We use a list as the frame table and use the functions from list.h
in order to locate and find the according frames. The struct frame uses
a spte_ptr that points to the spte it maps to in the frame table. 

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that are aliases for the same
>> frame, or alternatively how do you avoid the issue?

Our code coordinates accessed and dirty bits between the kernel and user VA
by the pagedir_accessed and pagedir_drty methods from pagedir.c. 

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

Each frame has a lock that would help synchronize for this race condition.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual memory-to-physical memory mappings?

We utilized a list for simplicity since they would map to physical addresses
through the virtual address. 

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.


---- ALGORITHMS ----

>> B2: When a frame is required but none are free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

Out code goes by the eviction policy FIFO which keeps track of the frame to 
evict in a variable based on the requests of frames throughout the paging 
system. 

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect that Q no longer has the frame?

We unload the data from the page taht the frame points to with a method
called spte_unload which was not implemented. We use this to unload the data
from the VA and free it whe nthe process Q no longer needs the pages. 

>> B4: Explain your heuristic for deciding whether or not  page fault 
>> for an invalid virtual address should cause the stack to be extended.

Because the stack page could end up 32 bytes below the esp because of the pusha
command, and that it is a spte that could not be found then we would call
grow_vm_stack depending on which context we are in. If it is user, then we 
call f->esp else in kernel it is cur->esp. 

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

Whenever a frame is being changed/modified then  then we would use the 
frame_lock in order to go through and assure that changes for the frame
happens one at a time. 

As for spte, we lock the whole table as the race condition where the spte
could be faulted then modified for no reason.

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

However not implemented, we would use an eviction lock in order to assure
 that the evicting of Q's frame and q faulting the page back in does not 
 occur.

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

   We would also acquire the lock for the frame within that time as well.  
    

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

    During exception.c any invalid virtual addresses are called exit(-1)
    as they would fail the access and should not continue in any process
    such as growing the stack or searching for the spte. 

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

    We chose multiple locks as this allows for the modification of multiple 
    frames at the same time and other eviction across frames within the paging
    system.

		 MEMORY MAPPED FILES (Extra Credit)
		 ==================================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

> Any other comments?
