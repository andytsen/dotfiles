
Objectives:
~~~~~~~~~~~

More C:

   - string manipulation
   - table lookup
   - file I/O

Assignment:
~~~~~~~~~~~

We will continue to develop our simple scripting language from p4. Here
are the changes:

- Scripts are read from files
- Scripts are multi-line
- ids can contain multiple characters
- we have real keywords
- curly braces for code blocks
- The interpreter accepts command line arguments and passes them to the
  script

Please remember that this is neither a programming languages nor a
complier development class; we're using the parser/interpreter as
an example of a complex C program that we need to write.


The language:
~~~~~~~~~~~~~

A program consists of a sequence of one or more statement separated by ';'

Spaces, tabs, and new line characters serve as keyword, identifier, and
literal value terminators but are ignored otherwise.

Statements are assigned implicit sequential labels 0, 1, ... from left
to right

The operators are as follows:

x + y => x + y
x - y => x - y
x * y => x * y
x > y => 1 if x > y, 0 otherwise
x < y => 1 if x < y, 0 otherwise
x ~ y => 1 if x is not equal to y, 0 otherwise

'*' has higher precedence than the other operators

Parenthesis could be used to influence evaluation order

10 + 20 * 2 => 50
(10 + 20) * 2 => 60

Identifiers (used to name variables) consist of up to 100 lower case letters.

Variables are not declared before use. All variables are initialize to 0.

Here are the different statements:

   - The assignment statement: <id> = <expression>
   - The if statement: if <expression> then <statement>
   - The goto statement: goto <expression>
   - The print statement: print <expression>


Full syntax:

 <program> := <stmt>
            | <stmt> ; <program>

 <stmt>    := <id> = <exp>
            | if <exp> <stmt>
            | { <program> }
            | print <exp>
            | goto <exp>

 <exp>     := <term> + <exp>
            | <term>

 <term>    := <factor>
            | <factor> * <term>

 <factor>  := ( <exp> )
            | <id>
            | <int>

The interpreter is run as follows:

./s29 <file name> arg0 arg1 arg2 ....

Where:

   - <file name> is the name of a file in the current directory that contains
     the script to run

   - arg0, arg1, ... are optional integer arguments. main is expected to
     process up to 26 arguments and assign the ones that are given as
     follows:


            * arg0 -> a
            * arg1 -> b
            * arg2 -> c
            * ...
            * arg25 -> z

Example:
~~~~~~~~

Let's say the following script is stored in a file named s1:

xyz = a;
pqr = c;
print xyz+pqr

- invoking it with "./s29 s1 10 20 30" prints 40
- invoking it with "./s29 s1" print 0 (all variables are initialized to 0)
- invoking it with "./s29 s1 100 200 300 500" prints 400

Files
~~~~~

You're not given any program or header files other than an empty main.c. You
need to structure your program in a convenient manner. The Makefile will compile
any .c files it finds in the project directory then link them together.


Hints:
~~~~~~

- I left a commented out version of my parser in a file named parser.c. Feel
  free to borrow from it.

- Feel free to borrow from your p4 implementation but keep in mind that there
  are differences between the two languages

- A recursive parsers that generates an AST followed by a recursive interpreter
  that interprets the AST recommended but not required.

- Look for information on the following library/system calls (open, read,
  close, setjmp, malloc, free, strdup, strcmp)


Files you're supposed to leave alone:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Makefile                        -- rules for compiling and running the program
   prog*.s29,prog*.args,prog*.ok   -- test scripts

To compile:
~~~~~~~~~~~

    make

To run test:
~~~~~~~~~~~~

    make clean test

To make the output less noisy:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    make -s clean test

To run one test
~~~~~~~~~~~~~~~

    make prog1.test

To run a test directly
~~~~~~~~~~~~~~~~~~~~~~

    make
    ./s29 prog1.s29 10 20 30

To debug with gdb
~~~~~~~~~~~~~~~~~

    make
    gdb ./s29
    (gdb) run prog1.s29 39 40 399

    Modify the program name and arguments to match what you want to debug

Test files
~~~~~~~~~~~

The following files are given for each test (e.g. prog1)

prog1.s29          -- The test script
prog1.args         -- The arguments to pass to the script
prog1.ok           -- The expected output

prog1.out          -- The actual output
prog1.diff         -- The difference between prog1.out and prog1.ok
prog1.res          -- either "pass" if the test passed (the output matches)
                      or details about the failure
color argonaut
