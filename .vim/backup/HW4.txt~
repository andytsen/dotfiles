1.
    proc:
        irmovq $0, %rax     %rax = 0 // value is changed to that
        irmovq $1, %r9      %r9 = 1
        rrmovq %rdi, %r8    %r8 = %rdi
        andq   %r8, %r8     checks if %r8 is 0 by %r8 & %r8
        je     done         if %r8 is zero then ret, else enter loop
    loop:
        andq    %rsi, %rax  moves %rsi into %rax (one of the orgs)
        subq    %r9, %r8    subtracts one from %r8 (%r8)
        andq    %r8, %r8    checks if it is zero
        jne     loop        enters loop by checking if above instruction reg is zero
    done        
        ret                 returns value %rax

2.
    %rsi * %rdi. If it is overflowing (due to being too large) 
    then it will be the wrong thing.

3. 
    int proc(int x, int y) {
        int r = 0;
        while(y != 0) {
            r += x;
            y--;
        }
        return r;
    } 


4.  0x100: 30F80000000000000000     irmovq $0, %rax
    0x10A: 30F90100000000000000     irmovq $1, %r9
    0x118: 20780000000000000000     rrmovq %rdi, %r8
    0x122: 6288                     andq %r8, %r8
    0x124: 73 a000000000000000      je done
    0x12E: | loop: 0x012E : 6070 |  loop: addq %rsi, %rax 
    0x131: 6198                     subq %r9, %r8
    0x133: 6288                     andq r8, %r8
    0x135: 7412E00000000000000      jne loop
    0x13E: Done                     done:
    0x13E: 90                       ret 


5. E = (A & B) | ((B | C) & (B & C));
    
    // program for it
    printf("A B C | W X Y Z | Q\n");
    printf("-------------------\n");
 
    for(int i = 0; i < 8; i++) {
        int a = (i & 0x4) >> 2;
        int b = (i & 0x2) >> 1;
        int c = (i & 0x1);
        int w = a & b;
        int y = b & c;
        int x = b | c;
        int z = x & y;
        int E = z | w;
        printf("%d %d %d | %d %d %d %d | %d", a, b, c, w, x, y, z, E);
    }

