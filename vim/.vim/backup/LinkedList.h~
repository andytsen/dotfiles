#include <iostream>
using namespace std;

template <class T>
class Node<T> {
   T data;
   Node* next; 

   public:
        bool operator < (const Node& node) const {
            return (this->data < node.x); 
        }

        bool operator <= (const Node& node) const {
            return (this->data <= node.x);
        }
       
        bool operator > (const Node& node) const {
            return (this->data > node.x);
        }

        bool operator >= (const Node& node) const {
            return (this->data >= node.x);
        }
};

template <class T>
class LinkedList<T> {

    friend istream& << operator() {
        T v; 
        
        while() {

        }
    }

    friend ostream& >> operator(ostream& out, const LinkedList& list) {
        Node* curr = list.head;
        while(curr) {
             out << curr->data;
             out << " ";
        }
        delete curr;
    } 
    int size;
    Node* head;

    public:
        // regular constructor
        LinkedList() {
            head = NULL;
            size = 0;
        }
        
        // copy construction
        LinkedList(LinkedList& otherlist) {
            Node* curr = otherlist.head;
            head = new Node(curr->data);
            Node* n = head;
            while(curr) {
                n = n->next;
                curr = curr->next;
                n = new Node(curr->data);
            }
            size = otherlist.size;
            delete n, curr;
        }

        // deconstructor
        ~LinkedList() {
            Node* n = head;
            Node* nodetoDel = head;
            while(n) {
                nodetoDel = n;
                n = n->next;
                delete nodetoDel;
            }
            delete n;
        }

        LinkedList& operator = (const LinkedList& list) {
            Node curr* = list.head;
            Node build* = head; // this head

            // traversing
            while(curr) {
               build = curr;
               build = build->next;
               curr = curr->next;  
            }

            LinkedList result = new LinkedList(this);

            delete curr, build;
            return result;
        }
        
        bool operator == (const LinkedList& list) const {
            Node curr* = list.head;
            Node build* = head;

            while(curr) { 
                if(curr->data != build->data) {
                    delete curr, build;
                    return false;
                }
            }

            delete curr, build;
            return true;
        }
        
        bool operator != (const LinkedList& list) const {
            Node curr* = list.head;
            Node build* = head;

            while(curr) { 
                if(curr->data != build->data) { 
                    delete curr, build;
                    return true; 
                }
            }

            delete curr, build;
            return false;
        }
        
        LinkedList operator + (const YourTemplateType v) const {
            Node* curr = head;
            while(curr->next) {
                curr = curr->next;
            } 
            curr->next = new Node(v);

            delete curr;
            return this;
        }
       
        LinkedList operator + (const LinkedList& list) const {
            Node* curr = head;
            while(curr->next) {
                curr = head->next;
            }
            
            Node* iter = list.head;
            while(iter) {
                curr->next = iter;
                iter = iter->next;
                curr = curr->next;
            }
            LinkedList result = new LinkedList(this);
            
            delete curr, iter;
            return result;
        }
        
        LinkedList operator - (const YourTemplateType v) const {
            Node* curr = head;
            Node* prev = head;
            while(curr) {
                if(curr->data == v) {
                    prev->next = curr->next;
                    break;
                }
                prev = curr;
                curr = curr->next;
            } 
            
            LinkedList result = new LinkedList(this);
            return result;
        }
        
        LinkedList operator - (const LinkedList& list) const {
            Node* othercurr = list.head;

            while(othercurr) {
                Node* curr = head;
                while(curr) {
                   if(curr == othercurr) {
                                     
                   } 
                }   
                othercurr = othercurr->next; 
            }
            

            delete curr;
            return result;
        }
        
        YourTemplateType& operator [] (const int index) const {}


};

